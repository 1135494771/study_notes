# [日志系统](#日志系统)

## 目录

- ## 基本概念

  - #### 1.日志级别
  
    - ``` 日志级别
      /*从高到低*/
      Critical(产生了不可逆的错误，系统无法正常工作) > Error(错误信息) > Warning(警告信息) > Information(普通输出信息) > Debug(调试信息) > Trace(记录详细信息)
      ```

  - #### 2.日志提供者

    - 日志提供者(LoggingProvider)：把日志输出到哪里。比如控制台、文件、邮箱、微信等。

- ## 使用

  - #### 输出到控制台

    - 安装安装包

      ``` NuGet安装
      Microsoft.Extensions.Logging
      Microsoft.Extensions.Logging.Console
      ```

    - 使用案例

      ``` 使用案例
      static void Main(string[] args)
      {
          //创建DI ServiceCollection对象
          ServiceCollection services = new ServiceCollection();
          services.AddLogging(logBuilder => { 
              //输出到控制台
              logBuilder.AddConsole();
              //设置文件最小输出等级
              logBuilder.SetMinimumLevel(LogLevel.Debug); 
          });
          //注入LogginController 服务对象
          services.AddScoped<LogginController>();
          using (ServiceProvider provider = services.BuildServiceProvider())
          {
              var temp = provider.GetRequiredService<LogginController>();
              //执行服务对象方法
              temp.RecordLog();
          }
      }

      /*实现类*/
      internal class LogginController
      {
          //一般默认 ILogger<当前类>
          private readonly ILogger<LogginController> logger;

          //使用构造函数方式注入 ILogger对象
          public LogginController(ILogger<LogginController> _logger)
          {
              this.logger = _logger;
          }

          public void RecordLog()
          {
              logger.LogDebug("调试日志");
              logger.LogError("错误日志");
              logger.LogInformation("信息日志");
              logger.LogWarning("警告日志");
          }

      }
      ```
    

- ### 选项方式读取配置

  - 1.推荐使用选项方法读取，和DI结合更好，且更好利用 "reloadOnChange" 机制。

  - 2.安装安装包

    ``` NuGet安装
    Microsoft.Extensions.Options
    Microsoft.Extensions.Configuration
    Microsoft.Extensions.Configuration.Binder
    Microsoft.Extensions.Configuration.Json
    ```

  - 3.读取配置的时候，DI需要声明IOptions<T>、IOptionsMonitor<T>、IOptionsSnapshot<T>等类型

      ``` 三者区别：
      /*三者区别*/
      IOptions<T>不会读取到新的值，只有当程序重启了才会读取到新的值; 视情况而使用
      IOptionsMonitor<T>当配置修改了那就读取新的值，但是容易发生逻辑混乱出现bug，不推荐使用
      IOptionsSnapshot<T> 不需要重新启动程序当重新进入这个范围会读取新的值，推荐使用
      ```

  - 4.使用案例
  
    ``` 使用案例
    static void Main(string[] args)
    {
        //使用DI 依赖注入方法读取配置
        ServiceCollection services = new ServiceCollection();
        //添加服务对象
        services.AddScoped<OptionReadController>();
        //创建一个ConfigurationBuilder对象
        ConfigurationBuilder configurationBuilder = new ConfigurationBuilder();
        //读取ConfigFolder 文件夹下 config.json
        configurationBuilder.AddJsonFile("ConfigFolder/config.json", optional: true, reloadOnChange: true);
        //创建IConfigurationRoot对象
        IConfigurationRoot configurationRoot = configurationBuilder.Build();

        //绑定Config 到 IConfigurationRoot上  !!! 这个是重点
        services.AddOptions().Configure<Config>(e => configurationRoot.Bind(e));
        using (ServiceProvider provider = services.BuildServiceProvider())
        {
            while (true)
            {
                using (IServiceScope scope = provider.CreateScope())
                {
                    var temp = scope.ServiceProvider.GetRequiredService<OptionReadController>();
                    temp.Test();
                }
            }
        }
    }
    ```

- ### 保命的UserSecrets

  - 1.Net提供了user-secrets机制，user-secrets的配置不放到配置中。
  - 2.NuGet安装：Microsoft.Extenstions.Configuration.UserSecrets
  - 3.在VS项目中右击[管理用户机密]，编辑这个配置文件。会自动在csproj中     UserSecretsId就是这个文件的名称
  - 4.configBuilder.AddUserSecrets<Program>(); //！！ 注意只有在本地有这个东西，生产中没有这个
